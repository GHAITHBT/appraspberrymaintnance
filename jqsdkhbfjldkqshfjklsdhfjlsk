import RPi.GPIO as GPIO
import time
import threading
import logging
import requests
import socket
from threading import Thread
import json

# Setup logging
logging.basicConfig(
    filename='button_log.log',
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# GPIO Pin Configuration
LED_DOWNTIME = 8
LED_MAINTENANCE = 7
LED_EMERGENCY = 12
LED_DOWNTIME_ALERT = 17
LED_CANCEL = 16

BUTTON_DOWNTIME = 11
BUTTON_MAINTENANCE = 5
BUTTON_EMERGENCY = 6
BUTTON_CANCEL = 13
SENSOR_OBSTACLE = 3

# Main Flask app API base URL
MAIN_API_BASE_URL = "http://10.110.30.15:1250/api"

# Global state
TEAM_NAME = None
last_sensor_trigger = time.time()
downtime_triggered = False
selected_led = None
is_first_run = True
event_start_time = None
awaiting_user_id = False
start_user_id = None
start_comment = None
end_comment = None
sensor_alert_active = False  # New flag for sensor alert state

# ... (keep get_ip_address, fetch_machine_name, setup_gpio, send_event_async, reset_system, 
# display_lcd_simulation, get_user_id_from_input, get_comment_from_input, 
# get_cancel_reason_from_input as they are)

def monitor_buttons_and_downtime():
    global last_sensor_trigger, downtime_triggered, selected_led, is_first_run, event_start_time, awaiting_user_id, start_user_id, start_comment, end_comment, sensor_alert_active
    
    prev_sensor = GPIO.HIGH
    prev_downtime = GPIO.HIGH
    prev_maintenance = GPIO.HIGH
    prev_emergency = GPIO.HIGH
    prev_cancel = GPIO.HIGH
    
    flash_state = False
    last_flash_time = time.time()
    
    while True:
        try:
            curr_sensor = GPIO.input(SENSOR_OBSTACLE)
            curr_downtime = GPIO.input(BUTTON_DOWNTIME)
            curr_maintenance = GPIO.input(BUTTON_MAINTENANCE)
            curr_emergency = GPIO.input(BUTTON_EMERGENCY)
            curr_cancel = GPIO.input(BUTTON_CANCEL)
            
            # Initial sensor trigger for first run
            if prev_sensor == GPIO.HIGH and curr_sensor == GPIO.LOW and is_first_run:
                logger.info(f"Sensor triggered on GPIO {SENSOR_OBSTACLE} for {TEAM_NAME}")
                print(f"Sensor triggered on GPIO {SENSOR_OBSTACLE}")
                last_sensor_trigger = time.time()
                if downtime_triggered or selected_led:
                    reset_system(selected_led_to_event_type(selected_led))
            
            # Downtime alert when no sensor signal for 5 seconds
            if time.time() - last_sensor_trigger > 5 and not downtime_triggered and not selected_led:
                logger.info(f"5 seconds passed without sensor trigger for {TEAM_NAME} - Turning on all LEDs")
                print("5 seconds passed without sensor trigger - Turning on all LEDs")
                GPIO.output(LED_DOWNTIME, GPIO.HIGH)
                GPIO.output(LED_MAINTENANCE, GPIO.HIGH)
                GPIO.output(LED_EMERGENCY, GPIO.HIGH)
                GPIO.output(LED_DOWNTIME_ALERT, GPIO.HIGH)
                GPIO.output(LED_CANCEL, GPIO.HIGH)
                downtime_triggered = True
                is_first_run = False
            
            # Handle sensor signal during an active event
            if selected_led and not awaiting_user_id:
                if prev_sensor == GPIO.HIGH and curr_sensor == GPIO.LOW and not sensor_alert_active:
                    logger.info(f"Sensor detected machine working during {selected_led_to_event_type(selected_led)} event for {TEAM_NAME}")
                    print(f"WARNING: Machine working detected during {selected_led_to_event_type(selected_led)}!")
                    sensor_alert_active = True
                    display_lcd_simulation("WARNING: Machine Active During Event!")
                
                elif prev_sensor == GPIO.LOW and curr_sensor == GPIO.HIGH and sensor_alert_active:
                    logger.info(f"Sensor stopped during {selected_led_to_event_type(selected_led)} event for {TEAM_NAME}")
                    print(f"Sensor stopped. Resuming {selected_led_to_event_type(selected_led)} event.")
                    sensor_alert_active = False
                    display_lcd_simulation(f"Resuming {selected_led_to_event_type(selected_led)}")
                    last_sensor_trigger = time.time()  # Reset sensor trigger to avoid immediate downtime
            
            # Flash LEDs during sensor alert or selected event
            if time.time() - last_flash_time >= 0.25:
                flash_state = not flash_state
                last_flash_time = time.time()
                
                if sensor_alert_active:
                    # Flash all LEDs to simulate buzzing
                    GPIO.output(LED_DOWNTIME, GPIO.HIGH if flash_state else GPIO.LOW)
                    GPIO.output(LED_MAINTENANCE, GPIO.HIGH if flash_state else GPIO.LOW)
                    GPIO.output(LED_EMERGENCY, GPIO.HIGH if flash_state else GPIO.LOW)
                    GPIO.output(LED_DOWNTIME_ALERT, GPIO.HIGH if flash_state else GPIO.LOW)
                    GPIO.output(LED_CANCEL, GPIO.HIGH if flash_state else GPIO.LOW)
                elif selected_led and not awaiting_user_id:
                    # Flash only the selected LED when no sensor alert
                    GPIO.output(selected_led, GPIO.HIGH if flash_state else GPIO.LOW)
            
            # Button handling (only when not awaiting user input)
            if not awaiting_user_id:
                if prev_downtime == GPIO.HIGH and curr_downtime == GPIO.LOW:
                    logger.info(f"Downtime button PRESSED on GPIO {BUTTON_DOWNTIME} for {TEAM_NAME}")
                    print(f"Downtime button PRESSED on GPIO {BUTTON_DOWNTIME}")
                    if selected_led == LED_DOWNTIME:
                        awaiting_user_id = True
                        end_user_id = get_user_id_from_input("Enter User ID to end downtime: ")
                        end_comment = get_comment_from_input("Enter End Comment (or press Enter to skip): ")
                        reset_system("downtime", end_user_id, end_comment)
                    elif downtime_triggered and not selected_led:
                        GPIO.output(LED_MAINTENANCE, GPIO.LOW)
                        GPIO.output(LED_EMERGENCY, GPIO.LOW)
                        GPIO.output(LED_DOWNTIME_ALERT, GPIO.LOW)
                        GPIO.output(LED_CANCEL, GPIO.LOW)
                        selected_led = LED_DOWNTIME
                        downtime_triggered = False
                        event_start_time = time.time()
                        awaiting_user_id = True
                        start_user_id = get_user_id_from_input("Enter User ID to start downtime: ")
                        start_comment = get_comment_from_input("Enter Start Comment (or press Enter to skip): ")
                        send_event_async("downtime", start_user_id=start_user_id, start_comment=start_comment)
                        awaiting_user_id = False
                
                elif prev_maintenance == GPIO.HIGH and curr_maintenance == GPIO.LOW:
                    logger.info(f"Maintenance button PRESSED on GPIO {BUTTON_MAINTENANCE} for {TEAM_NAME}")
                    print(f"Maintenance button PRESSED on GPIO {BUTTON_MAINTENANCE}")
                    if selected_led == LED_MAINTENANCE:
                        awaiting_user_id = True
                        end_user_id = get_user_id_from_input("Enter User ID to end maintenance: ")
                        end_comment = get_comment_from_input("Enter End Comment (or press Enter to skip): ")
                        reset_system("maintenance", end_user_id, end_comment)
                    elif downtime_triggered and not selected_led:
                        GPIO.output(LED_DOWNTIME, GPIO.LOW)
                        GPIO.output(LED_EMERGENCY, GPIO.LOW)
                        GPIO.output(LED_DOWNTIME_ALERT, GPIO.LOW)
                        GPIO.output(LED_CANCEL, GPIO.LOW)
                        selected_led = LED_MAINTENANCE
                        downtime_triggered = False
                        event_start_time = time.time()
                        awaiting_user_id = True
                        start_user_id = get_user_id_from_input("Enter User ID to start maintenance: ")
                        start_comment = get_comment_from_input("Enter Start Comment (or press Enter to skip): ")
                        send_event_async("maintenance", start_user_id=start_user_id, start_comment=start_comment)
                        awaiting_user_id = False
                
                elif prev_emergency == GPIO.HIGH and curr_emergency == GPIO.LOW:
                    logger.info(f"Emergency button PRESSED on GPIO {BUTTON_EMERGENCY} for {TEAM_NAME}")
                    print(f"Emergency button PRESSED on GPIO {BUTTON_EMERGENCY}")
                    if selected_led == LED_EMERGENCY:
                        awaiting_user_id = True
                        end_user_id = get_user_id_from_input("Enter User ID to end emergency: ")
                        end_comment = get_comment_from_input("Enter End Comment (or press Enter to skip): ")
                        reset_system("emergency", end_user_id, end_comment)
                    elif downtime_triggered and not selected_led:
                        GPIO.output(LED_DOWNTIME, GPIO.LOW)
                        GPIO.output(LED_MAINTENANCE, GPIO.LOW)
                        GPIO.output(LED_DOWNTIME_ALERT, GPIO.LOW)
                        GPIO.output(LED_CANCEL, GPIO.LOW)
                        selected_led = LED_EMERGENCY
                        downtime_triggered = False
                        event_start_time = time.time()
                        awaiting_user_id = True
                        start_user_id = get_user_id_from_input("Enter User ID to start emergency: ")
                        start_comment = get_comment_from_input("Enter Start Comment (or press Enter to skip): ")
                        send_event_async("emergency", start_user_id=start_user_id, start_comment=start_comment)
                        awaiting_user_id = False
                
                elif prev_cancel == GPIO.HIGH and curr_cancel == GPIO.LOW and selected_led:
                    logger.info(f"Cancel button PRESSED on GPIO {BUTTON_CANCEL} for {TEAM_NAME}")
                    print(f"Cancel button PRESSED on GPIO {BUTTON_CANCEL}")
                    awaiting_user_id = True
                    cancel_reason = get_cancel_reason_from_input()
                    GPIO.output(LED_CANCEL, GPIO.HIGH)
                    time.sleep(0.5)
                    GPIO.output(LED_CANCEL, GPIO.LOW)
                    reset_system(selected_led_to_event_type(selected_led), cancel_reason=cancel_reason)
                    awaiting_user_id = False
            
            prev_sensor = curr_sensor
            prev_downtime = curr_downtime
            prev_maintenance = curr_maintenance
            prev_emergency = curr_emergency
            prev_cancel = curr_cancel
            
            time.sleep(0.01)
        except Exception as e:
            logger.error(f"Error in monitor_buttons_and_downtime: {e}")
            print(f"Error in monitor_buttons_and_downtime: {e}")

# ... (keep selected_led_to_event_type and main functions as they are)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("System shutdown via keyboard interrupt")
        print("\nShutting down...")
